1. Объявляем [] массив, при помощи + преобразовуем его в строку 1 при помощи + происходит конкатенация 2  = "12";
2. alert проверяете тип переменной f, а она отсуствует области видимости поэтому undefined.
3. В переменной а, мы создали массив с двумя значеиями 1 и 2 в переменной мы объявили к-во значений, но не заполнили их поэтому массив пустой.
4. Выражение !!(a && b) возвращает значение логического типа true или false, при помощи !! мы приводим условие к логическому типу. 
   Выражение (a && b) - возвращает первый из операндов, значение которого приводится к логическому если оба верны вернет последний.
5. Функция sayHi(); вызывает значение из глобальной переменной где значение Вася, в нее мы не передаем локальную переменую со значением Петя.
6. Не правильно прочитал условие, думал сколько можно передать параметров в функцию, если мы ее вызываем а не объявляем.
7. Тут сложно сказать почему именно так, просто так было написано в документации.
8. i++ возравщаем значение, кототорое было при объявлении.
   ++i увеличиваем значение на 1, которое было при объявлении.
9. Два разных языка.
10. Потому что, '0' и 0 это один и тот-же элемент, который равен 2. Так как после объявлении "0": 1 мы перпресвоили 0 к 2.
11. Перепрасвоили нулл к объекту вызвали значение по ключу 0 = 1-первй элемент + [1] - второй элемент = 2. Вызываем значение по ключу 1 = 2.
12. +
13. +
14. Обращаемся к строке "1" при значение которого [0]
15. Встроенное «наследование» при помощи свойства prototype
16. Буква ё идет раньше по в алфавите чем я
17. -
18. Ссылаемся на значение переменной f, а не саму переменную.
19. -
20. 4 далее при - преобразуем "5" к числу = -1 + 0xf(это тоже число шестнадцатеричное) - преобразует "1e1" к числу = числовое значение.
